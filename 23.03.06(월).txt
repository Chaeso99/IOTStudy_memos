23.03.06(월)
<오전수업> 다트예제 실행은 메인함수 위의 Run버튼 누르기(F5로 실행안됨)
플러터/안드로이드 스튜디오 설치
https://velog.io/@jaybon/%ED%94%8C%EB%9F%AC%ED%84%B0-%EC%84%A4%EC%B9%98
ㄴflutter --version이 안될경우 cmd를 관리자 권한으로 실행

교재는 미사용

UI프레임워크 플러터
- 크로스 플랫폼

안드로이드/ios/web/window/mac/linux
-퓨시아OS ->구글에서 밀고있는 OS(지금은 IOT기기에만 많이 사용, 나중에는 안드,
 데스크탑 등에도 많이 들어올것)
<리액트 네이티브 vs 플러터>
-리액트 네이티브의 장점:자바스크립트로 짤 수 있다./리액트를 알면 쉽게 접근 가능하다.
/코드 push가 가능하다.
-리액트 네이티브의 단점:느리다

-플러터의 장점:빠르다(코드가 안드/IOS 코드로 변환)
-플러터의 단점:코드 푸시가 안된다./Dart라는 언어를 배워야 한다.(자스랑 자바 섞은 느낌의 언어)

최신 UI 개발은 모두 플러터와 비슷한 방식으로 구현한다.
(리액트, IOS, 안드로이드 등)

<스스로 정리하기>
Dart의 특징
1. 모든 것들이 전부 Object로 취급한다.(함수, number, null 등 모두)
2. List<int>, List<dynamic> 같은 제너릭 타입을 지원한다.
3. Typed 언어지만 자유도를 준다.
4. Public, private, protected의 정의가 없으며, _function()으로 정의된다.

Skia 엔진이란?
C++로 개발된 오픈소스 2D 그래픽 라이브러리. OpenGL의 Canvas를 사용해 렌더링

AOT와 JIT란?
JIT(Just In Time):브라우저에서 파일들을 다운로드 한 뒤 한번 컴파일해 브라우저 엔진이
실행가능한 저수준 언어로 변경 후 화면을 렌더링하는 방식
(실행 시점에 바이트코드를 기계어로 번역) 
실행속도가 상대적으로 느리고, 앱 설치 속도나 설치 용량 등이 AOT에 비해 이득이고, 브라우저에서 여러 에러들을
발생시키고 확인 및 디버깅이 가능하고, CPU사용이 AOT에비해 높음. 
사용 예시:JVM/CLR

AOT(AheadOfTime):소스 코드를 미리 컴파일하는 방식(설치 시점에 기계어로 번역)
실행속도가 상대적으로 빠르고 ,설치 속도는 느리고, 설치 용량은 크고, CPU 사용이
JIT에 비해 낮음. 
사용 예시:C/C++
-------------------------------------------------------------------------------------------
다트예제 .git 파일 지우고 자기 깃헙에 올리고 링크 보내기
<오후수업>
tempList1.sort(매개변수:함수)
sort/map/where/forEach

final check(int a, int b){
return a-b;
}
[1, 2, 3, 2, 1].sort(check); 하면 첫번째 1,2에 대해 check 함수 실행=>
결과값 -1이 나옴=>앞의 숫자가 더 작으니까 그대로 1,2 유지
=>check(2,3)=>(check3,2)=>결과값이 +니까 자리바꿈=>check(3,1)=>결과값이 +니까
자리바꿈...
https://www.youtube.com/watch?v=ebI54DXYQG8
ㄴ버블정렬 유튜브(춤 영상)
-------------------------------------------------------------------------
  // 문제 5. sort를 이용해서 tempList1을 정렬하고 출력하시오.
List타입의 tempList1 
tempList1.sort(매개변수 : 함수)
sort / map / where / forEach

final check(int a, int b){
    return a - b;
}

[1, 2, 3, 2, 1].sort(check);
check(1, 2) -> 결과값 -1 유지
check(2, 3) -> 결과값 -1 유지
check(3, 2) -> 결과값 +1 자리바꿈
[1, 2, 2, 3, 1]
check(3, 1) ->  결과값 +2 자리바꿈
한번 더 체크
[1, 2, 2, 1, 3] 
......
[1, 1, 2, 2, 3] 오름차순 정렬이 된다.

정렬방식

var power(dynamic item){
    return item * 2;
}

tempList1.map(power)

[1, 2, 3]

power(1) -> 결과값 2
power(2) -> 결과값 4
power(3) -> 결과값 6

[2, 4, 6]
------------------------------------------------------------------------
실행 단축키 컨트롤 알트 N