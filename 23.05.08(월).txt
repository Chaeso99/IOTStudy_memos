23.05.08(월)	팀은 그대로/(유광열강사님 담당)/앱개발 포함할수도 있음
최종 프로젝트:jsp 프로젝트를-> 스프링 부트 프로젝트로 만드는것 
ㄴ기간 - 5월 15일~ 6월 5일까지
IOT 수업:2~3주(10, 11, 12, 17, 18, 19 +@)
예전에 계산기 등 만들어둔 앱 프로그램 깃허브 링크 보내기
앱보다는 웹이 크고 기회가 많음
29일은 정상출근
--------------------------------------------------------------------------------------------------
빈시간 이용해서 프로젝트 준비하기(15일부터 바로 시작, todoList 프로젝트 분석해서 세팅하기)
ㄴDB는 그대로 사용하면됨(수정 필요하면 수정)/MGR -> Mybatis 세팅(DB연결)/Repository, Service, Controller 세팅+Security(로그인/권한) 등 부가적인 내용/로직은 JSP에서 모두 제거하고 레포지토리, 서비스, 컨트롤러로 이관 =>앱 개발은 결정되면 안내(일단 제외)
-------------------------------------------------------------------------------------------------
배울것:밸리데이션, 에러 핸들링, AOP, 로그, 시큐리티
못한 것들(공부해야하는 기술):JPA, JWT
<강사님 설명>
밸리데이션 == 유효성 체크:로그인 시 아디비번 넣을때 아무것도 안집어넣고 누르면 아이디를 입력해주세요 등등 뜨는게 두가지임(요청을 보내는지 확인). 화면에서 처리하는거(jsp, html 등)/서버에서 처리하는거 두번 해야함. (서버는 요청 데이터를 신뢰하지 않는다.)-POSTMAN 등의 프로그램을 통해 이상한 데이터를 클라이언트가 보낼 수 있기 때문임
밸리데이션 종류:@Size, @NotNull, @NotEmpthy, @NotBlank, @Max, @Min, @AssertTrue/False, @Valid 등등
밸리데이션 라이브러리는 꼭 필요하지만 귀찮은 유효성 체크를 어노테이션으로 쉽게 처리하도록 도와준다. 
데이터베이스의 NULL을 NOT NULL으로 변경할것임. 변경하는 순간 터지는 에러를 대처하기 위해서 에러 처리 OR 밸리데이션을 해줘야됨.
성능:
밸리데이션 - DB 조회 전(훨씬 빠름)
에러 처리 - DB INSERT 하다가 터짐(성능 안좋음)
쓰레기 데이터를 DB에 접근 못하도록 막는게 웹 개발자의 중요한 역할이다.
밸리데이션 라이브러리 추가해서 설정(메이븐 리파지토리 - 라이브러리 가져오기->build.gradle 라이브러리 추가 + 프로젝트 다시 로드
데이터를 받아오는 객체 안의 필드 값에 @NotBlank 같은거 추가 >컨트롤러 매개변수에 @Validated 추가 -> 상태코드가 자동으로 400이 보내짐. 에러내용이 자동으로 세팅 됨

에러 핸들링: 스샷 참조
MethodArgumentNotValidException
1.같은에러가 여러군데 발생함 2.에러를 확인하고 @RestControllerAdvice
함수 생성 후 @ExceptionHandler
exception.getBindingResult().getFieldErrors()를 이용해서 에러 메세지를 가공해서 전달한다.

로그:콘솔에 떠있는 메세지. 서버를 켜면 메세지가 한줄씩 올라오면서 데이터가 나오게 된다.
개발할때는 로그데이터를 보고있지만 서버 실사용시에는 하루종일 확인할 수 없으니까 저장해놨다가 나중에 확인 - 저장하는걸 로깅 이라고 함
프레임워크 개발할때는 system.out.println 대신 따로 프레임워크 사용함 (@Slf4j 등)
application.yml 파일에 설정 몇줄 추가.

ResDTO는 화면에 보낼 정보가 담겨있음.
(code/message/data) https://developer.mozilla.org/ko/docs/Web/HTTP/Status 상태 코드 찾기
400시리즈는 클라이언트 (유저) 잘못
500시리즈는 개발자 코드 잘못
ㄴ
200 OK
요청이 성공적으로 되었습니다. 성공의 의미는 HTTP 메소드에 따라 달라집니다: GET: 리소스를 불러와서 메시지 바디에 전송되었습니다. HEAD: 개체 해더가 메시지 바디에 있습니다. PUT 또는 POST: 수행 결과에 대한 리소스가 메시지 바디에 전송되었습니다. TRACE: 메시지 바디는 서버에서 수신한 요청 메시지를 포함하고 있습니다.

201 Created
요청이 성공적이었으며 그 결과로 새로운 리소스가 생성되었습니다. 이 응답은 일반적으로 POST 요청 또는 일부 PUT 요청 이후에 따라옵니다.

400 Bad Request
이 응답은 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없음을 의미합니다.

401 Unauthorized
비록 HTTP 표준에서는 "미승인(unauthorized)"를 명확히 하고 있지만, 의미상 이 응답은 "비인증(unauthenticated)"을 의미합니다. 클라이언트는 요청한 응답을 받기 위해서는 반드시 스스로를 인증해야 합니다.

403 Forbidden
클라이언트는 콘텐츠에 접근할 권리를 가지고 있지 않습니다. 예를들어 그들은 미승인이어서 서버는 거절을 위한 적절한 응답을 보냅니다. 401과 다른 점은 서버가 클라이언트가 누구인지 알고 있습니다.

405 Method Not Allowed
요청한 메소드는 서버에서 알고 있지만, 제거되었고 사용할 수 없습니다. 예를 들어, 어떤 API에서 리소스를 삭제하는 것을 금지할 수 있습니다. 필수적인 메소드인 GET과 HEAD는 제거될 수 없으며 이 에러 코드를 리턴할 수 없습니다.

500 Internal Server Error
서버가 처리 방법을 모르는 상황이 발생했습니다. 서버는 아직 처리 방법을 알 수 없습니다.

HttpEntity:HTTP 요청또는 응답에 해당하는 HttpHeader와 HttpBody를 포함하는 클래스
ResponseEntity:(상태코드 Status Code/헤더 Headers/바디 body())왼쪽의 세가지를 담고있음
헤더를 보내는 경우:쿠키 등

REST 컨트롤러로 데이터 리턴 시:무조건 ResponseEntity + ResDTO 세트로 사용

AOP(관점 지향 프로그래밍)-핵심관심(계좌이체, 이자계산, 입출금 등 핵심기능), 횡단관심(로깅, 보안, 트랜잭션 등 여러 핵심기능에서 공통으로 수행되어야하는 기능)으로 이루어짐

공통기능(Aspect)를 전에(Before)수행하느냐, 이후에(After)수행하느냐가 중요함. 공통기능이 실행되는 위치는 PointCut 이라고 한다.
Proxy:대행자
@Before, @After : Request, Response를 건드리지 못한다.(들어오고 나가는 데이터 조작 불가)
@Around : Request, Response를 건드릴수 있다.(들어오고 나가는 데이터 조작 가능)